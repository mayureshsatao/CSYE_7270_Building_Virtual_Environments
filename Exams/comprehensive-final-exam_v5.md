# Game Development Final Exam - Version 5
## Total: 100 points

---

### Question 1 (5 pts)
Which of the following properties can be used to control a Rigidbody's interaction with physics in Unity? (Select all that apply)

- [ ] IsKinematic  
- [ ] UseGravity  
- [ ] StaticFriction  
- [ ] Mass  
- [ ] CollisionMatrix  

---

### Question 2 (5 pts)
Which Unity event functions will run after all Update calls are completed? (Select all that apply)

- [ ] LateUpdate  
- [ ] FixedUpdate  
- [ ] PostRender  
- [ ] OnDrawGizmos  
- [ ] OnSceneLoad  

---

### Question 3 (5 pts)
Which of the following are valid methods to handle user input in Unity? (Select all that apply)

- [ ] Input.GetKey  
- [ ] Input.GetAxis  
- [ ] InputSystem.PollEvents  
- [ ] Input.GetButtonDown  
- [ ] Input.PressKey  

---

### Question 4 (5 pts)
In computer graphics, which maps are used to add surface detail without adding geometry? (Select all that apply)

- [ ] Normal maps  
- [ ] Diffuse maps  
- [ ] Displacement maps  
- [ ] Ambient occlusion maps  
- [ ] Specular maps  

---

### Question 5 (5 pts)
What properties are typically included in a physically-based rendering (PBR) material? (Select all that apply)

- [ ] Base Color/Albedo  
- [ ] Metallic  
- [ ] Roughness/Smoothness  
- [ ] Temperature  
- [ ] Script Reference  

---

### Question 6 (5 pts)
In Unreal Engine, what are valid Blueprint communication methods? (Select all that apply)

- [ ] Direct Function Calls  
- [ ] Event Dispatchers  
- [ ] Interfaces  
- [ ] Data Tables  
- [ ] Form Submissions  

---

### Question 7 (5 pts)
Which programming practices can help reduce garbage collection pauses in Unity C# code? (Select all that apply)

- [ ] Using object pooling  
- [ ] Avoiding string concatenation in Update  
- [ ] Creating new List<T> objects frequently  
- [ ] Using foreach loops on collections  
- [ ] Caching component references  

---

### Question 8 (5 pts)
Which of the following are true about delegates in C#? (Select all that apply)

- [ ] They allow methods to be passed as parameters  
- [ ] They are value types  
- [ ] They can reference multiple methods (multicast)  
- [ ] They are used to create serialized data  
- [ ] They improve garbage collection  

---

### Question 9 (5 pts)
What methods can be used to improve character animation quality in games? (Select all that apply)

- [ ] Inverse Kinematics (IK)  
- [ ] Blendshapes/Morph targets  
- [ ] Animation layers  
- [ ] Forward Kinematics Optimization  
- [ ] Animation Retargeting  

---

### Question 10 (5 pts)
Which of these techniques can be used for camera collision avoidance in third-person games? (Select all that apply)

- [ ] Raycasting from target to camera  
- [ ] Sphere casting from target to camera  
- [ ] Camera smoothing  
- [ ] Spring-arm component  
- [ ] Lens distortion adjustment  

---

### Question 11 (5 pts)
What are valid ways to optimize particle systems in games? (Select all that apply)

- [ ] Reducing max particle count  
- [ ] Using simpler collision detection  
- [ ] Increasing texture resolution  
- [ ] Using flipbook animations  
- [ ] Setting higher simulation quality  

---

### Question 12 (5 pts)
Which techniques can reduce overdraw in transparent effects? (Select all that apply)

- [ ] Alpha testing instead of alpha blending  
- [ ] Sorting particles back-to-front  
- [ ] Using opaque materials when possible  
- [ ] Using larger particles  
- [ ] Adding more transparent layers  

---

### Question 13 (5 pts)
Which of the following statements about root motion in character animation are true? (Select all that apply)

- [ ] It extracts movement from animation data  
- [ ] It provides more realistic character movement  
- [ ] It requires more animator configuration  
- [ ] It automatically avoids all obstacles  
- [ ] It reduces CPU usage in all scenarios  

---

### Question 14 (5 pts)
Which animation techniques are commonly used in modern fighting games? (Select all that apply)

- [ ] Animation canceling  
- [ ] Hitbox/Hurtbox systems  
- [ ] Motion matching  
- [ ] Pose matching  
- [ ] Server-authoritative animation  

---

### Question 15 (5 pts)
In audio design, which techniques can create a more immersive 3D sound experience? (Select all that apply)

- [ ] HRTF (Head-Related Transfer Function)  
- [ ] Audio occlusion  
- [ ] Reverb zones  
- [ ] Audio compression  
- [ ] Bit-depth reduction  

---

### Question 16 (5 pts)
What factors affect the perceived loudness of in-game audio? (Select all that apply)

- [ ] Distance from listener  
- [ ] Audio occlusion by geometry  
- [ ] Environmental factors (water, caves)  
- [ ] View frustum culling  
- [ ] Audio normalization  

---

### Question 17 (5 pts)
Which rendering techniques can improve performance in games with many lights? (Select all that apply)

- [ ] Light baking  
- [ ] Clustered forward rendering  
- [ ] Screen-space reflections  
- [ ] Light culling  
- [ ] Shadow map cascades  

---

### Question 18 (5 pts)
Which optimization techniques apply to mobile game development? (Select all that apply)

- [ ] Reducing draw calls  
- [ ] Using lower resolution textures  
- [ ] Implementing occlusion culling  
- [ ] Using more dynamic lighting  
- [ ] Increasing polygon count for smoother edges  

---

### Question 19 (5 pts)
Which are common components of a behavior tree AI system? (Select all that apply)

- [ ] Sequence nodes  
- [ ] Selector nodes  
- [ ] Decorator nodes  
- [ ] Rendering nodes  
- [ ] Collision nodes  

---

### Question 20 (5 pts)
What features are typically found in commercial game engines? (Select all that apply)

- [ ] Physics simulation  
- [ ] Audio systems  
- [ ] Rendering pipelines  
- [ ] Automatic code optimization  
- [ ] AI programming  

---

### Question 21 (5 pts)
Which types of colliders are more performance-efficient in physics engines? (Select all that apply)

- [ ] Box colliders  
- [ ] Sphere colliders  
- [ ] Capsule colliders  
- [ ] Mesh colliders (convex)  
- [ ] Mesh colliders (non-convex)  

---

### Question 22 (5 pts)
Which data structures would be appropriate for efficiently storing a large open-world terrain? (Select all that apply)

- [ ] Quadtrees  
- [ ] Height maps  
- [ ] Octrees  
- [ ] Linked lists  
- [ ] Chunk-based arrays  

---

### Question 23 (5 pts)
Which are valid methods for implementing a health system in games? (Select all that apply)

- [ ] ScriptableObject to store health data  
- [ ] Component-based design with a Health component  
- [ ] Event-based damage system  
- [ ] Singleton health manager  
- [ ] Registry-based entity targeting  

---

### Question 24 (5 pts)
Which of the following are effective ways to implement a day-night cycle in an open-world game? (Select all that apply)

- [ ] Rotating a directional light  
- [ ] Changing the skybox material  
- [ ] Adjusting post-processing settings  
- [ ] Modifying the game's physics timestep  
- [ ] Changing the audio engine's decay factor  

---

### Question 25 (5 pts)
What techniques can help reduce load times in games? (Select all that apply)

- [ ] Asset streaming  
- [ ] Level of Detail (LOD) systems  
- [ ] Asset bundling  
- [ ] Asynchronous loading  
- [ ] Just-in-time compilation  

---

# Answer Key

### Question 1
**Correct Answers**: IsKinematic, UseGravity, Mass
> **Explanation**: IsKinematic makes a Rigidbody ignore forces and move only through transform changes. UseGravity toggles gravity's effect on the Rigidbody. Mass determines how forces affect the Rigidbody. StaticFriction is not a Unity property, and CollisionMatrix is not a Rigidbody property (collision layers are set separately).

### Question 2
**Correct Answers**: LateUpdate, OnDrawGizmos
> **Explanation**: LateUpdate runs after all Update functions have completed, making it useful for camera following. OnDrawGizmos runs after rendering for editor visualization. FixedUpdate runs at fixed intervals for physics, not tied to Update. PostRender is not a standard Unity event, and OnSceneLoad doesn't exist (Unity uses OnSceneLoaded instead).

### Question 3
**Correct Answers**: Input.GetKey, Input.GetAxis, Input.GetButtonDown
> **Explanation**: Input.GetKey checks if a specific key is pressed. Input.GetAxis reads axis input like joysticks or WASD movement. Input.GetButtonDown detects when a mapped button is pressed down. InputSystem.PollEvents and Input.PressKey are not valid Unity input methods.

### Question 4
**Correct Answers**: Normal maps, Ambient occlusion maps, Specular maps
> **Explanation**: Normal maps simulate surface detail by affecting how light bounces off surfaces. Ambient occlusion maps simulate shadows in crevices. Specular maps control highlight intensity. Diffuse maps provide color/texture but don't add detail. Displacement maps actually modify geometry by displacing vertices.

### Question 5
**Correct Answers**: Base Color/Albedo, Metallic, Roughness/Smoothness
> **Explanation**: Standard PBR materials include Base Color/Albedo (surface color), Metallic (whether surface is metal or non-metal), and Roughness/Smoothness (how sharply the surface reflects light). Temperature and Script Reference are not standard PBR properties.

### Question 6
**Correct Answers**: Direct Function Calls, Event Dispatchers, Interfaces
> **Explanation**: Unreal Engine Blueprints can communicate through Direct Function Calls (when one Blueprint has a reference to another), Event Dispatchers (for broadcasting events to multiple listeners), and Interfaces (for standardized communication between different Blueprint types). Data Tables store data but aren't communication methods. Form Submissions is not an Unreal Engine concept.

### Question 7
**Correct Answers**: Using object pooling, Avoiding string concatenation in Update, Caching component references
> **Explanation**: Object pooling reuses objects instead of creating/destroying them. Avoiding string operations in frequently called methods reduces allocations. Caching component references (GetComponent once in Start) prevents repeated lookups. Creating new List objects frequently and using foreach (which creates hidden enumerators) both cause garbage collection.

### Question 8
**Correct Answers**: They allow methods to be passed as parameters, They can reference multiple methods (multicast)
> **Explanation**: Delegates are reference types (not value types) that can be used to pass methods as parameters. Multicast delegates can reference and invoke multiple methods. They aren't related to serialization or garbage collection, though they can cause allocations if not handled properly.

### Question 9
**Correct Answers**: Inverse Kinematics (IK), Blendshapes/Morph targets, Animation layers, Animation Retargeting
> **Explanation**: IK adjusts bones to meet positioning goals (like foot placement). Blendshapes deform meshes for facial expressions. Animation layers allow mixing animations (upper/lower body). Animation retargeting applies animations to different skeletons. "Forward Kinematics Optimization" is not a standard animation technique.

### Question 10
**Correct Answers**: Raycasting from target to camera, Sphere casting from target to camera, Spring-arm component
> **Explanation**: Raycasting checks for obstacles between the character and camera. Sphere casting uses a sphere instead of a ray for smoother results. Spring-arm components (like in Unreal) handle collision avoidance with damping. Camera smoothing affects movement smoothness but not collision. Lens distortion is a visual effect, not collision avoidance.

### Question 11
**Correct Answers**: Reducing max particle count, Using simpler collision detection, Using flipbook animations
> **Explanation**: Fewer particles means less computation. Simpler collision (or none) reduces physics calculations. Flipbook animations (texture animation) can simulate complex effects with fewer particles. Increasing texture resolution and higher simulation quality both increase performance cost, not reduce it.

### Question 12
**Correct Answers**: Alpha testing instead of alpha blending, Using opaque materials when possible
> **Explanation**: Alpha testing is binary (pixel visible or not) and reduces overdraw compared to blending. Opaque materials don't contribute to overdraw. Sorting back-to-front is necessary for correct transparency but doesn't reduce overdraw. Larger particles and more transparent layers both increase overdraw.

### Question 13
**Correct Answers**: It extracts movement from animation data, It provides more realistic character movement, It requires more animator configuration
> **Explanation**: Root motion uses movement baked into animations for more natural motion rather than script-driven movement. It requires more setup in the animator controller. It doesn't automatically avoid obstacles and can be more CPU-intensive than script-driven movement in some cases.

### Question 14
**Correct Answers**: Animation canceling, Hitbox/Hurtbox systems, Motion matching
> **Explanation**: Fighting games use animation canceling to allow fluid combos, hitbox systems for precise collision detection during attacks, and increasingly motion matching for realistic movement. Pose matching is not a standard fighting game technique, and fighting games typically use client-side or deterministic lockstep netcode rather than server-authoritative animation.

### Question 15
**Correct Answers**: HRTF (Head-Related Transfer Function), Audio occlusion, Reverb zones
> **Explanation**: HRTF simulates how sound interacts with a human head for realistic directionality. Audio occlusion simulates sound blockage by obstacles. Reverb zones create appropriate acoustic environments. Audio compression and bit-depth reduction are technical limitations that can reduce quality, not immersion-enhancing techniques.

### Question 16
**Correct Answers**: Distance from listener, Audio occlusion by geometry, Environmental factors (water, caves)
> **Explanation**: Sound attenuates with distance. Obstacles between sound and listener reduce volume. Environmental factors like underwater effects or cave reverb affect perceived loudness. View frustum culling is a rendering concept, not audio. Normalization adjusts overall levels but doesn't affect dynamic loudness perception.

### Question 17
**Correct Answers**: Light baking, Clustered forward rendering, Light culling
> **Explanation**: Light baking pre-computes lighting into textures. Clustered forward rendering efficiently groups lights by 3D space. Light culling prevents processing lights that don't affect visible objects. Screen-space reflections are for reflections, not light optimization. Shadow map cascades improve shadow quality but don't necessarily improve performance with many lights.

### Question 18
**Correct Answers**: Reducing draw calls, Using lower resolution textures, Implementing occlusion culling
> **Explanation**: Mobile devices benefit from fewer draw calls due to CPU limitations. Lower resolution textures reduce memory usage and fill rate requirements. Occlusion culling prevents rendering unseen objects. More dynamic lighting and higher polygon counts both increase rendering load, contrary to mobile optimization goals.

### Question 19
**Correct Answers**: Sequence nodes, Selector nodes, Decorator nodes
> **Explanation**: Behavior trees use sequence nodes (execute children in order until one fails), selector nodes (try children until one succeeds), and decorator nodes (modify child node execution like inverters or repeaters). Rendering nodes and collision nodes are not standard behavior tree components but belong to rendering and physics systems.

### Question 20
**Correct Answers**: Physics simulation, Audio systems, Rendering pipelines, AI programming
> **Explanation**: Commercial game engines like Unity and Unreal include physics systems, audio management, rendering technology, and AI tools. While they include optimization features, "automatic code optimization" that automatically rewrites your code for better performance is not a standard feature.

### Question 21
**Correct Answers**: Box colliders, Sphere colliders, Capsule colliders
> **Explanation**: Primitive colliders (box, sphere, capsule) are much more efficient than mesh colliders because their collision detection uses simple mathematical formulas. Mesh colliders, especially non-convex ones, are significantly more performance-intensive as they involve more complex calculations.

### Question 22
**Correct Answers**: Quadtrees, Height maps, Octrees, Chunk-based arrays
> **Explanation**: Large terrains benefit from spatial partitioning structures like quadtrees (2D) and octrees (3D), height maps for elevation data, and chunk-based systems for streaming and LOD. Linked lists lack spatial organization and would be inefficient for terrain lookups.

### Question 23
**Correct Answers**: ScriptableObject to store health data, Component-based design with a Health component, Event-based damage system, Singleton health manager
> **Explanation**: All four are valid approaches: ScriptableObjects can store health configuration, component-based designs attach health to entities, event systems decouple damage sources from targets, and singletons can manage global health. "Registry-based entity targeting" is not a standard pattern for health systems.

### Question 24
**Correct Answers**: Rotating a directional light, Changing the skybox material, Adjusting post-processing settings
> **Explanation**: Day-night cycles typically involve rotating the sun/moon directional light, transitioning between day/night skyboxes, and adjusting post-processing for time-of-day effects. Physics timesteps and audio decay factors are unrelated to visual time-of-day systems.

### Question 25
**Correct Answers**: Asset streaming, Asset bundling, Asynchronous loading
> **Explanation**: Loading times are reduced by streaming assets as needed rather than all at once, bundling related assets to reduce file access operations, and loading asynchronously to prevent freezing the game. LOD systems improve runtime performance but don't directly affect load times. Just-in-time compilation can actually increase load times in some contexts.
